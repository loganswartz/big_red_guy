//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use anyhow::Result;
use base64::{engine::general_purpose, Engine};
use constant_time_eq::constant_time_eq;
use rand::{RngCore, SeedableRng};
use rocket::async_trait;
use sea_orm::{
    entity::prelude::*,
    ActiveValue::{NotSet, Set},
};

#[derive(EnumIter, DeriveActiveEnum, Eq, PartialEq, Debug, Clone)]
#[sea_orm(rs_type = "String", db_type = "String(Some(1))")]
pub enum EventType {
    #[sea_orm(string_value = "password_reset")]
    PasswordReset,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "transactional_events")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub hash: String,
    pub event_type: EventType,
    pub primary_user_id: Option<i32>,
    pub secondary_user_id: Option<i32>,
    pub misc_data: Option<String>,
    pub created_at: TimeDateTimeWithTimeZone,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::users::Entity",
        from = "Column::PrimaryUserId",
        to = "super::users::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    PrimaryUser,
    #[sea_orm(
        belongs_to = "super::users::Entity",
        from = "Column::SecondaryUserId",
        to = "super::users::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    SecondaryUser,
}

#[async_trait]
impl ActiveModelBehavior for ActiveModel {
    /// Automatically set the created_at field to the current time.
    async fn before_save<C>(mut self, _db: &C, _insert: bool) -> Result<Self, DbErr>
    where
        C: ConnectionTrait,
    {
        if let NotSet = self.created_at {
            self.created_at = Set(TimeDateTimeWithTimeZone::now_utc());
        };

        Ok(self)
    }
}

/// A securely-generated random token, and a corresponding TransactionalEvent prefilled with a hash
/// of that token.
pub struct TokenTuple {
    pub token: String,
    pub event: ActiveModel,
}

impl ActiveModel {
    /// Generate a new TransactionalEvent with a securely-generated random token.
    ///
    /// Ideally this would have overridden ActiveModelBehavior::new(), but the signature of
    /// ActiveModelBehavior::new() doesn't allow us to return a Result, and we also needed a
    /// way to return the unencrypted token since it's not going to be stored in the database.
    ///
    /// Returns a TokenTuple struct containing the raw token and the (unsaved) ActiveModel.
    pub fn generate() -> Result<TokenTuple> {
        // generate 128 bits of randomness for a token
        // equivalent to ~22 characters of base64
        let mut rng = rand_chacha::ChaCha20Rng::from_entropy();
        let mut token = [0u8; 16];
        rng.try_fill_bytes(&mut token)?;

        // convert to base64, and then hash with SHA256
        let encoded = general_purpose::URL_SAFE_NO_PAD.encode(token);
        // we don't need to use argon2 here because the token is already fully random
        // algos like argon2 are needed for passwords because passwords are not entirely random
        let hash = sha256::digest(&encoded);

        Ok(TokenTuple {
            token: encoded,
            event: Self {
                hash: Set(hash),
                ..ActiveModelTrait::default()
            },
        })
    }
}

impl Model {
    /// Verify that a token matches the hash of this TransactionalEvent.
    ///
    /// This is used to verify that a token is valid for a given event.
    /// For example, if a user is resetting their password, we can verify that the token they
    /// provide matches the hash of the token we have stored in the database.
    ///
    /// Uses a constant-time comparison algorithm to prevent timing attacks.
    pub fn verify_token(&self, token: &str) -> bool {
        constant_time_eq(&sha256::digest(token).as_bytes(), &self.hash.as_bytes())
    }
}

impl Entity {
    pub fn find_from_token(token: &str) -> Select<Self> {
        let hash = sha256::digest(token);
        Self::find_by_id(hash)
    }
}

pub struct TransactionalEventPrimaryUser;

impl Linked for TransactionalEventPrimaryUser {
    type FromEntity = Entity;
    type ToEntity = super::users::Entity;

    fn link(&self) -> Vec<RelationDef> {
        vec![Relation::PrimaryUser.def()]
    }
}

pub struct TransactionalEventSecondaryUser;

impl Linked for TransactionalEventSecondaryUser {
    type FromEntity = Entity;
    type ToEntity = super::users::Entity;

    fn link(&self) -> Vec<RelationDef> {
        vec![Relation::SecondaryUser.def()]
    }
}
